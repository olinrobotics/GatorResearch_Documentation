\chapter{The Robot Software System (LabVIEW)}

In this chapter, the LabVIEW portion of the software will be discussed. Do note that there will be some features of the software such as timed while loops that will seem strange at first glance and the reason for the use of those features will not be written in this chapter. It is likely that such features are used as part of good LabVIEW FPGA programming practice and such practices will be documented in an Appendix at the end of this report. So, do remember to look at that section to fully understand the use of features such as timed while loops.

\section{The FPGA Hindbrain}
As discussed in the software overview chapter, the Hindbrain of the vehicle is implemented on a LabVIEW FPGA in order to ensure that control loops and essential data processing is done at the fastest possible speeds to reduce system latency even when the vehicle travels at higher speeds. \\ \\
%
The front panel and block diagram of the top-level hindbrain VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.55]{Photos/hindbrainblock_annotated.png}
\caption{Hindbrain top-level VI block diagram with subchapters annotated}
\label{fig:hindbrainblock}
\end{figure} 

\newpage

\noindent As can be seen in Figure \ref{fig:hindbrainblock}, the main subchapters of the FPGA hindbrain are:

\begin{enumerate}
\item Sensing Loop
\item Acting Loop
\item Tilt Unit Drive Status Monitors
\item LiDAR Reading
\item Supporting Hardware Control
\item Relay Control
\end{enumerate}

\subsection{Sensing Loop}

The sensing loop of the FPGA hindbrain essentially passes status information and data from other parts of the FPGA hindbrain code up to the front panel so that the real-time code can access these variables. The block diagram for the sensing loop shown in Figure \ref{fig:hindbrainblock} is shown zoomed in below: 

\begin{figure}[h!]
\centering
\includegraphics[scale=1.5]{Photos/sensingloop.png}
\caption{Sensing loop in the hindbrain VI}
\label{fig:sensingloop}
\end{figure} 

\noindent As shown in Figure \ref{fig:sensingloop}, the sensing loop is responsible for exposing front panel elements for the following pieces of data to the real-time code:

\begin{enumerate}
\item Left LiDAR Encoder Position: A debugging indicator that shows the encoder position of the left LiDAR in units of encoder ticks
\item Left Tilt Unit State: A cluster containing an indicator for whether the index had been found, whether the tilt unit has been told to be in initialize mode, whether there is a position error in the tilt unit and the encoder position.
\item Right Tilt Unit State: The same cluster as the left tilt unit state cluster used for the right tilt unit
\item Left LiDAR Position: Another debug indicator that shows the position of the left tilt unit in degrees after the encoder ticks have been converted to degrees
\item Negative Steer Endstop: A boolean that represents whether the negative steer angle endstop has been triggered
\item Positive Steer Endstop: A boolean that represents whether the positive steer angle endstop has been triggered
\item Estop Engaged: A boolean that represents whether either of the physical estop buttons have been triggered
\item Odometer (meters): The distance travelled by the vehicle since the code started running
\item Throttle state: A cluster containing indicators for the gas and brake pedal voltage being sent to the linear actuators for the gas and brake respectively
\item DriveState: A cluster indicating the driving state of the vehicle including the steering wheel angle in degrees, the velocity in miles per  hour and the boolean that represents whether the vehicle should apply the brakes
\item SenseHeartBeat: An indicator that simply provides a blinking light that confirms the while loop is running 
\end{enumerate}

\subsection{Acting Loop}

The acting loop of the FPGA hindbrain essentially performs the opposite function of the sensing loop: to provide indicators for the real-time code to pass commands or instructions down to the FPGA code. The block diagram for the acting loop shown in Figure \ref{fig:hindbrainblock} is shown zoomed in below:

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=1.5]{Photos/actloop.png}
\caption{Acting loop in the hindbrain VI}
\label{fig:actloop}
\end{figure}

\noindent As shown in Figure \ref{fig:actloop}, the acting loop is responsible for providing front panel elements for the real-time code to send the following commands to the FPGA code:

\begin{enumerate}
\item Left Tilt Unit Command: A cluster that contains indicators for whether the tilt unit should be in initialize mode, the position setpoint of the tilt unit in degrees, the current output when the tilt unit is in initialize mode and a reset position boolean that indicates whether the position of the tilt units should be reset to zero.
\item Right Tilt Unit Command: The same cluster as Left Tilt Unit Command, but for the right tilt unit
\item Left Tilt Unit Settings: A cluster that contains the controller settings for the left tilt unit including the position proportional, integral and derivative (PID) gains, Current PI gains and the current limit
\item Right Tilt Unit Settings: The same settings cluster as the Left Tilt Unit Settings for the right tilt unit
\item Drive Command: A cluster containing the desired wheel angle in degrees, the desired velocity in miles per hour and a boolean to command the vehicle to apply the brakes
\item Steering Controller Settings: A cluster containing the controller settings for the steering control including the PID gains, upper and lower voltage limits, upper and lower encoder limits, PID to motor conversion constant, motor deadband high and low threshold, a reset position boolean for resetting the steer motor position and two other booleans to tell the vehicle whether to allow positive and negative steering voltages or not.
\item Throttle Controller Settings: Cluster containg the throttle controller settings for the gas and brake controllers including the PID gains for the gas pedal controller, voltage offset that indicates the neutral position voltage, position reset and PID reset boolean, maximum and minimum brake voltage, maximum and minimum gas pedal voltage and the speed of the throttle control loop. 
\end{enumerate}

\subsection{Tilt Unit Drive Status Monitors}
The tilt unit drive status monitors essentially provide inputs and outputs that allow the real-time code to command the NI9505 motor control modules and receive information on the status of the modules. The block diagram for the tilt unit drive status monitors shown in Figure \ref{fig:hindbrainblock} is shown zoomed in below:

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=1.2]{Photos/tudrivestat.png}
\caption{Tilt unit drive status monitors in the hindbrain VI}
\label{fig:tudrivestat}
\end{figure}

\noindent As can be seen in Figure \ref{fig:tudrivestat}, the left and right drive status loops are basically identical to each other except for the module assignments since the left drive status monitor addresses the NI9505 module for the left tilt unit and the right drive status monitor addresses the other NI9505 module. \\ \\
%
Each drive status monitor loop contains a method for enabling the drive, disabling the drive and monitoring the presence of a power supply (vsup Present), whether the drive has a drive fault (Drive Fault), determining whether the drive is enabled or disabled (Drive Status) and whether the drive is overheating (Over Temperature Fault). By default, the NI9505 modules will be disabled when the vehicle is first powered up and so the drive will need to be enabled in software during initialization. 

\subsection{LiDAR Reading}

Although LiDAR reading shows up on the front panel of the Hindbrain top-level VI as one subVI, the process of reading data from the two Sick LMS291 LiDARs really involves several different subVIs to perform the various tasks. In summary, the process of reading data from the LiDARs involves:

\begin{enumerate}
\item Initializing the LiDARs
\item Read the raw data from the LiDARs
\item Parse and transform the LiDAR data into the vehicle's coordinate system
\end{enumerate}

\noindent On the hindbrain top-level VI, the block diagram for reading the LiDARs shown in Figure \ref{fig:hindbrainblock} is shown zoomed in below:

\begin{figure}[h!]
\centering
\includegraphics[scale=2]{Photos/lidarread.png}
\caption{LiDAR Reading SubVI in the hindbrain VI}
\label{fig:lidarread}
\end{figure}

\noindent As can be seen in Figure \ref{fig:lidarread}, the lidar reading VI takes the offsets for the left (Leonardo) and right (Raphael) LiDARs that provide the translations and rotations that are needed to transform the LiDAR data in the last step of the LiDAR reading process.\\ \\
%
The block diagram of the LiDAR reading VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/readlidarblock.png}
\caption{Block diagram for the Lidar Reading VI}
\label{fig:readlidarblock}
\end{figure}

\noindent As can be seen in Figure \ref{fig:readlidarblock}, the LiDAR reading VI consists of a flat sequence with three parts:

\begin{enumerate}
\item The first part is an FPGA I/O method node that sets the the input and output lines
\item The second part contains a VI for the left and right LiDAR that sends the commands specified in the LiDAR communication protocol to tell the LiDAR to send data continuously at 25Hz
\item The third part contains two subVIs: a serial read/write VI that writes the required commands to the LiDAR and receives the LiDAR data back and a transformer VI that transforms the LiDAR data coordinate system from the LiDAR's local coordinate system to the vehicle's coordinate system.
\end{enumerate}

\subsection{LiDAR Serial Read/Write}

The block diagram for the LiDAR serial read/write VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/readlidar_block.png}
\caption{Block diagram for the Lidar Reading VI}
\label{fig:readlidar_block}
\end{figure}

\noindent As can be seen in Figure \ref{fig:readlidar_block}, the VI is essentially a wrapper for the actual FPGA read/write functions that allows the code to reuse the same read/write functions while being able to assign the inputs and outputs to the appropriate LiDARs (either left or right). The VI takes either the left (Leonardo) or right (Raphael) LiDAR name as input and assigns the following variables to the write function:

\begin{enumerate}
\item LIDARLeonardoWriteFIFO: A First In First Out (FIFO) queue that queues the LiDAR commands to be sent to the LiDAR 
\item Chassis1/Mod1/DIO3: The DIO chanel from which LiDAR data is transmitted
\item 543478: The baud rate for LiDAR communication
\item 8: Data bits for the LiDAR
\item None: Parity for the LiDAR
\item  1.0: Stop bits
\item True boolean: Reverse Polarity command for the LiDAR
\end{enumerate}

\noindent The read function is then assigned the following variables:

\begin{enumerate}
\item LeoPos: A FIFO queue that queues the lidar position data to be read by the transformer VIs
\item Chassis1/Mod1/DIO5: The DIO channel from which LiDAR data is received
\item LIDARLeonardoReadFIFO: THe FIFO queue that queues the received LiDAR data
\item 543478: The baud rate for LiDAR communication
\item 8: Data bits for the LiDAR
\item None: Parity for the LiDAR
\item  1.0: Stop bits
\item True boolean: Reverse Polarity command for the LiDAR
\end{enumerate}

\noindent These variables are then passed down to the actual serial write and read functions as shown below:

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/readwriteblocks.png}
\caption{Block diagram for the VI providing the actual read/write functions}
\label{fig:readwriteblocks}
\end{figure}

\noindent The serial write VI is a stock serial write VI provided by LabVIEW for the LiDARs that has been modified to include a while loop around the entire serial write sequence for the LiDARs. Therefore, for brevity in this report, the write VI will not be explained in detail. However, for convenience, the documentation for the serial write VI is shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/writedocs.png}
\caption{Documentation for the serial write function}
\label{fig:writedocs}
\end{figure}

\newpage

\noindent The block diagram for the serial read VI, then, is shown in the diagram below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{Photos/serialreadblock.png}
\caption{Block diagram for the serial read function}
\label{fig:serialreadblock}
\end{figure}

\noindent As can be seen in Figure \ref{fig:serialreadblock}, after setting the baud rate, the VI executes a series of steps each time throug the while loop to receive the bits that make up the LiDAR data that is received:

\begin{enumerate}
\item Wait for the start bit of the data
\item Read data
\item Read stop bit
\end{enumerate}

\noindent For brevity, this report is not going to discuss the code that waits for the start bit or the code that reads the stop bit. When zoomed in, the read data chapter of the code is as follows:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.85]{Photos/readdatasection.png}
\caption{Block diagram for the chapter that reads the LiDAR data bits}
\label{fig:readdatachapter}
\end{figure}

\newpage

\noindent As can be seen in Figure \ref{fig:readdatachapter}, the data reading code essentially reads each bit as a boolean and adds it to the array. Once the for loop has been through all the bits in the mesage, it converts the data and adds it to the read FIFO queue that queues up the LiDAR reading to be read by the transforming code. At the same time, code in parallel reads either the left or right encoder position (depending on whether Raphael or Leonardo is selected) and and appends the encoder tick count to a separate position FIFO queue to be read by the transformer code.

\subsection{LiDAR Data Transform}
After the LiDAR read/write functions, the next step in processing the LiDAR data is to transform it from the local LiDAR coordinate system to the vehicle coordinate system. 

\subsubsection{LiDAR Parse Transform and Send VI}
Referring back to Figure \ref{fig:readlidarblock}, the block on the far right is the VI that parses the LiDAR data, transforms it and then sends it over a FIFO queue up to the real-time layer. The block diagram for this VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Photos/lidartransformandsend.png}
\caption{Block diagram for the Parse Transform and Send VI}
\label{fig:parseandsend}
\end{figure}

\noindent As shown in Figure \ref{fig:parseandsend}, the transform and send VI runs a while loop that is constantly processing LiDAR data coming from the FIFO queues that was written to those queues by the LiDAR serial read/write VIs. Data from the upper FIFO queue (the LiDAR data read from the LiDAR) is passed through a LiDAR data parser that parses each piece of data, parses the checksum and other additional data in the LiDAR data, including the distance reading and the scan number. The scan number is sent up to the real-time layer and the distance reading is then sent to the next subfunction in the parse transform and send VI. \\ \\
%
The data from the lower FIFO queue (the position of the LiDAR in encoder ticks), then, is passed through a function that converts the encoder ticks to LiDAR position in degrees. That LiDAR position data is then passed to the next part of the transform code as the y-axis rotation (pitch).

\subsubsection{LiDAR to Robot Transform: Overview}
As shown in Figure \ref{fig:parseandsend}, the next step in the transform process is the transform itself. The data returned by the Sick LMS290 LIDARs is in the co-ordinate frame of the LIDARs by virtue of the way in which the LIDARs take readings. In order to do useful work with the LIDAR data, the LIDAR data has to be transformed to make it iwth reference to the vehicle co-ordinate system.

\subsubsection{Constant LIDAR Transform Properties}
Based on the design and placement of the LIDAR mounts, the following properties of the LIDAR transform are applied to make the transform:

\begin{enumerate}
\item For the left side LiDAR, the constant transforms are:
\begin{enumerate}
\item X translation: 2000mm
\item Y translation: 450mm
\item Z translation: 1000mm
\item Z rotation (yaw): 45 degrees
\end{enumerate}
\item For the right side LiDAR, the constant transforms are:
\begin{enumerate}
\item X translation: 2000mm
\item Y translation: -450mm
\item Z translation: 1000mm
\item Z rotation (yaw): -45 degrees
\end{enumerate}
\end{enumerate}

\noindent The observant reader will note that the Y rotation (pitch) of the LiDARs is nto a constant property and depends on the encoder tick count. This will be explained in more detail in the later sections. 

\subsubsection{The LiDAR Transform VI}

The block diagram for the LiDAR transform VI is shown below:
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Photos/transformvi.png}
\caption{Block diagram for the LiDAR transform VI}
\label{fig:transformvi}
\end{figure}

\noindent As can be seen in Figure \ref{fig:transformvi}, the transform process has four parts:

\begin{enumerate}
\item Flip the scan angle over to account for the LiDAR being mounted up-side-down and place 0 degrees in the center of the scan (i.e. such that 0 is in the center of the scan, 90 degress is on the right and -90 degrees is on the left 
\item Convert each scan from polar co-ordinates to cartesian co-ordinates
\item Rotate the coordinate frames such that the frame local to the LIDAR is in the same orientation as the vehicle co-ordinates
\item Translate the coordinate frames such that the frame local to the LIDAR is translated to line up with the vehicle co-ordinate system
\end{enumerate}

\noindent The rotations are necessary to align the local LiDAR coordinate axes with the vehicle coordinate axes. This is illustrated in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{Photos/lidarrobotaxes.png}
\caption{Diagram showing the LiDAR local axes (in the center of the LiDAR) and the vehicle axes (on the ground below the rear axle of the vehicle); X is red, Y is green, Z is blue}
\label{fig:lidarrobotaxes}
\end{figure}

\noindent As can be seen in Figure \ref{fig:lidarrobotaxes}, the local coordinate system of the LiDAR is rotated relative to the coordinate system of the vehicle by a yaw of 45 degrees and a pitch that is measured by the encoders on the tilt units. \\ \\
%
\noindent Within the timed while loop in Figure \ref{fig:transformvi}, some simple arithmetic is used to adjust the scan angles such that the center of the scan has a scan angle of zero degrees with positive to the left of center in the LiDAR's mounted position and negative to the right of center. Refer to Figure \ref{fig:sick_angledef} to help figure out the angle definition.\\ \\
%
Note that the very last addition block of the code within the timed while loop accounts for the yaw of the LiDAR resulting from the mounting position. As is noted in Figure \ref{fig:lidarrobotaxes}, the LiDARs are mounted such that the LiDAR is yawed away from the center of the vehicle by 45 degreees (i.e. 45 degrees to the driver's right for the right side LiDAR and 45 degrees to the driver's left for the left side LiDAR). Since the code within the timed while loop is already adjusting the scan angle of the LiDAR scans, the yaw of the LiDARs is also accounted for in that timed while loop for convenience.\\ \\
%
The next subVI converts the LiDAR scan data from polar coordinates (i.e. scan angle and measured distance) to cartesian (i.e. the coordinate of the point with an X, Y and Z component). The block diagram is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.9]{Photos/pol2cart.png}
\caption{Block diagram for the polar to cartesian transformer VI}
\label{fig:pol2cart}
\end{figure}

\noindent As can be seen in Figure \ref{fig:pol2cart}, the polar to cartesian transform is a standard implementation of how one would convert an angle and distance to an X and Y coordinate. For clarity, the following diagram demonstrates how this transform is done:

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{Photos/pol2cart_diag.png}
\caption{Diagram of the polar to cartesian transform}
\label{fig:pol2cart_diag}
\end{figure}

\noindent As per the diagram in Figure \ref{fig:pol2cart_diag}, the polar coordinates are transformed to cartesian coordinates usign simple trigonometry: The X coordinate is obtained by multiplying the distance measurement by cos(scan angle). The Y coordinate is obtained by multiplying the distance measurement by sin(scan angle). These calculations are exactly what are shown in the block diagram in Figure \ref{fig:pol2cart}.\\ \\
%
Returning to Figure \ref{fig:transformvi}, after the polar to cartesian conversion,
%
The block diagram of the VI performing the rotation transformation of the LiDAR measurements from the LiDAR local coordinates to the vehicle coordinates is shown in the figure below:

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{Photos/rotationblock.png}
\caption{Block diagram for the VI performing the rotation transform}
\label{fig:rotationblock}
\end{figure}

\noindent Referring to Figure \ref{fig:lidarrobotaxes}, to transform the LiDAR scan data from the LiDAR local coordinate frame to the robot coordinate frame, the scan data needs to be rotated by a yaw of 45 degrees and by the pitch of the tilt unit as measured by the tilt unit encoders. As described above, the yaw is accounted for in the timed loop in Figure \ref{fig:transformvi}. Therefore, the block diagram shown in Figure \ref{fig:rotationblock} accounts for the pitch of the LiDAR. The equations that perform this transform are:

\begin{equation}
X'=\cos(pitch)X + \sin(pitch)Z
\label{eq:Xrot}
\end{equation}
\begin{equation}
Y'=Y
\label{eq:Yrot}
\end{equation}
\begin{equation}
Z'=\cos(pitch)Z - sin(pitch)X
\label{eq:Zrot}
\end{equation}

\noindent where X, Y  and Z are the scan data coordinates before the transform (i.e. coordinates in the LiDAR coordinate frame) and X', Y' and Z' are scan data coordinates after the transform (i.e. coordinates in the LiDAR coordinate frame). See this website for more details on rotation transforms and rotation matrices: \url{http://mathworld.wolfram.com/RotationMatrix.html}. \\ \\
%
In the LiDAR coordinate frame, the Z height of the points is all zero since the LiDAR performs a planar scan. So, all the Z values are zero in Equations \ref{eq:Xrot} and \ref{eq:Zrot} are zero. Therefore, Equations \ref{eq:Xrot}, \ref{eq:Yrot} and \ref{eq:Zrot} reduce to:

\begin{equation}
X'=\cos(pitch)X
\label{eq:Xrot_simplified}
\end{equation}
\begin{equation}
Y'=Y
\label{eq:Yrot_simplified}
\end{equation}
\begin{equation}
Z'=- sin(pitch)X
\label{eq:Zrot_simplified}
\end{equation}

\noindent Equations \ref{eq:Xrot_simplified}, \ref{eq:Yrot_simplified} and \ref{eq:Zrot_simplified} are what is implemented in the block diagram shown in Figure \ref{fig:rotationblock}.\\ \\
%
Finally, referring back to Figure \ref{fig:transformvi}, the last part is the translate part highlighted in the figure. As shown in Figure \ref{fig:lidarrobotaxes}, to align the LiDAR and robot coordinate frames, there is a fixed X, Y and Z distance(also known as the X, Y and Z offsets) that separates the two coordinate frames. To transform the LiDAR scan data from the LiDAR coordinate frame to the robot coordinate frame, we essentially need to account for those fixed distances. As such, the 3 addition blocks in the translate part of Figure \ref{fig:transformvi} essentially add the X, Y and Z offsets to the X, Y and Z coordinates respectively that were output from the rotation VI. Therefore, the final result is the LiDAR data, properly transformed from the LiDAR coordinate frame to the vehicle LiDAR coordinate frame.

\subsubsection{Send LiDAR Point to PC}
Referring back to Figure \ref{fig:parseandsend}, after the VI that transforms the LiDAR scan data, the last step is to send that LiDAR scan data up to the real-time code. The block diagram for the parse transform and send VI is shown below:

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/inttobool.png}
\caption{Block diagram for the Parse Transform and Send VI}
\label{fig:inttobool}
\end{figure}

\noindent As can be seen in Figure \ref{fig:inttobool}, the VI takes the X, Y and Z coordinates of each LiDAR scan data point and the count which is the scan number (i.e. the nth point in the scan) for the point. The VI also takes the LiDAR that performed the scan coded as either 91 (right LiDAR) or 92 (left LiDAR). Using the number to boolean block, each integer number for X, Y, Z and count is converted to a boolean array. This is essentially converting each number into the bit definition for each number. The four boolean arrays are then concatenated together to form one long boolean array which is then passed to the write to PC VI to send to the real-time code.\\ \\
%
The block diagram for the Write to PC VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{Photos/sendtopc.png}
\caption{Block diagram for the Write to PC VI}
\label{fig:sendtopc}
\end{figure}

\noindent As can be seen in Figure \ref{fig:sendtopc}, the boolean array created from the integers in the Transform and Send VI is now combined with the LiDAR ID, which is also converted to a boolean array. The combined boolean array is then passed to a DMA FIFO queue that sends the data up to the real-time code from the FPGA.

\subsection{Supporting Hardware Control}

Referring back to Figure \ref{fig:hindbrainblock}, the last section of the code in that block diagram is the supporting hardware control VIs. That section of the block diagram is shown here zoomed in for convenience:

\begin{figure}[h!]
\centering
\includegraphics[scale=2.0]{Photos/supportinghardwarevis.png}
\caption{Zoomed in portion of the Hindbrain VI showing the supporting hardware VIs}
\label{fig:supportinghardwarevis}
\end{figure}

\noindent As can be seen in Figure \ref{fig:supportinghardwarevis}, there are 6 supporting hardware VIs:

\begin{enumerate}
\item Steer Motor: Controls the steering motor
\item Throttle Control: Controls the throttle and brakes
\item Rear End Stops: Senses the steering end stops
\item EStop Sense: Senses if the emergency stop switches on the vehicle (both the one in the cab and the one on the electronics box) have been depressed
\item Left TU: Controls the right tilt unit
\item Right TU: Controls the left tilt unit
\end{enumerate}

\newpage

\subsubsection{Steering Motor Control}

The block diagram for the steering motor controller is shown below:
\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{Photos/steermotorblock.png}
\caption{Block Diagram of the Steering Motor Controller VI}
\label{fig:steermotorblock}
\end{figure}

\noindent The block diagram shown in Figure \ref{fig:steermotorblock} is obtained from \url{http://zone.ni.com/devzone/cda/epd/p/id/1580}. As such, this report will not discuss every aspect of the code in detail but will isntead provide a general overview. \\ \\
%
As can seen in Figure \ref{fig:steermotorblock}, there are 4 parts to the block diagram:

\begin{enumerate}
\item The upper timed while loop simply reads the quadrature encoder ticks and keeps track of the position of the steer motor based on the number of encoder ticks. That position is then converted to steering wheel angle in degrees
\item The lower left timed while loop does several things:
\begin{enumerate}
\item Converted the steering wheel angle command to encoder ticks setpoint
\item Disseminates the steering controller settings to the appropriate parts in the code
\end{enumerate}
\item A PID block that takes in the desired setpoint, PID settings and the limit and produces an output
\item Finally, the lower right timed while loop simply checks the output from the PID block to make sure it is within the set lower and upper thresholds and is not within the deadband. 
\end{enumerate}

\noindent For the PID block, it is worth noting that the inputs and outputs to the PID block are required to all be a fixed-point number with a 16-bit word length, 32-bit integer length number. This means that the inputs and outputs to the PID block must all be integer multiples of 65536 (i.e. $2^{16}$). For this reason, the inputs are multiplied by 65536 and the outputs are divided by 65536.

\subsubsection{Throttle Control}

The block diagram for the VI that controls the gas and brake pedal is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/throttlecontrol.png}
\caption{Block Diagram of the Throttle Control VI}
\label{fig:throttlecontrol}
\end{figure}

\noindent As shown in Figure \ref{fig:throttlecontrol}, there are two main while loops:

\begin{enumerate}
\item The upper while loop simply monitors the quadrature encoder on the rear wheels and computes the velocity and distance traveled by the vehicle. 
\item The lower while loop then controls the gas pedal based on the speed of vehicle calculated in the upper while loop. The PID block in that while loop therefore controls the vehicle speed by comparing the calculated vehicle speed and the desired vehicle speed and produces an output that is used to control the gas pedal. 
\end{enumerate}

\noindent Also note that at the bottom of the bottom right timed while loop in Figure \ref{fig:throttlecontrol}, the loop also takes a boolean that represents whether the brakes need to be activated or not. The loop then controls the brake pedal to apply the brake when the boolean is true.

\subsubsection{Read End Stops}

The VI that reads the end stop sensors is simple and is shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/ReadEndStops.png}
\caption{Block Diagram of the Read End Stops VI}
\label{fig:readendstops}
\end{figure}

\noindent The VI simply reads the state of two digital pins, 1 for each end stop (cherry) sensor, and writes the boolean balue to the appropriate FPGA global variable. 

\newpage

\subsubsection{EStop Sense}

The block diagram for the VI that sense the activation of the emergency stop buttons on the vehicle is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/estopsense.png}
\caption{Block Diagram of Emergency Stop Sense VI}
\label{fig:estopsense}
\end{figure}

\noindent Like the Read End Stops VI, this VI also simply reads a digital pin to determine if either of the estop buttons on the vehicle have been depressed. The while loop then passes the boolean up to an FPGA gobal variable so that the real-time code can have access to that information.

\newpage

\subsubsection{Right and Left Tilt Unit Control}

The block diagram for the left and right tilt unit controllers is shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.65]{Photos/tucontroller.png}
\caption{Block Diagram of the Left and Right Tilt Unit Controller}
\label{fig:tucontroller}
\end{figure}

\noindent Note that although the left and right tilt unit controllers are separate VIs as shown in Figure \ref{fig:supportinghardwarevis}, the two VIs are exactly the same except for the chassis and module number that is set on the blocks that write and read from the NI modules since the left and right tilt units are each controlled by a separate NI 9505 module.\\ \\
%
As shown in Figure \ref{fig:tucontroller}, the tilt unit controller is made up of 6 parts:

\begin{enumerate}
\item Information exchange loop: The information exchange loop is simply responsible for reading the state of the tilt unit and writing commands to the tilt unit controller code. So, for example, the tilt unit commands are received from the real-time code and, through the information exchange loop, passed down to the relevant parts of the tilt unit control code. Similarly, the tilt unit state is read from the various parts of the tilt unit control code and, through the information exchange loop, is made available to the real-time code to read.
\item Position loop: The position loop simply provides PID control over the position of the tilt unit using the PID settings specified in the tilt unit settings cluster.
\item Current loop: The current loop simply provides PI control over the current output to the tilt unit motor using the PI settings specified in the tilt unit settings cluster.
\item Current Sampling: Samples the current output to the tilt unit motor.
\item Encoder loop: Reads the quadrature encoder on the tilt unit and keeps track of the position of the tilt unit in units of encoder ticks.
\item PWM Generation: Generates the PWM signal used to drive the tilt unit motor. 
\end{enumerate}

\noindent Note that there is a case statement around the desired current used in the PWM generation loop that selects the source of the desired current. Also note that there is a 'Init?' switch that allows the real-time code to switch the mode of the tilt unit controller to either be in init mode or normal running mode. \\ \\
%
The tilt unit controller code was designed to operate in the following way:

\begin{enumerate}
\item If the tilt unit is running in normal running mode (i.e. the 'Init?' switch is set to false), the six loops essentially carry out standard torque control to maintain the tilt unit at a desired setpoitn position. In this case, in the PWM generation loop, the source of the desired current is the current put out by the current loop.
\item If the tilt unit is running in initialize mode, the source of the desired current in the PWM generation loop is simply the desired initialize current set in the real-time code. In this case, the control output from the six loops is ignored and the PWM generation loop is simply given a fixed desired current to operate in during initialization.
\end{enumerate}

\subsection{Relay Control}

The last part of the Hindbrain VI shown in Figure \ref{fig:hindbrainblock} is the relay control. For convenience, the relay control portion of the block diagram is zoomed in and shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=1.4]{Photos/relaycontrolportion.png}
\caption{Block diagram of the relay control of portion of the hindbrain}
\label{fig:relaycontrolportion}
\end{figure}

\noindent This relay controller serves as a key safety system for the vehicle and the while loop allows LabVIEW to trigger the emergency stop system and will only allow the vehicle's autonomous systems to stay active only if all levels of control code (i.e. FPGA, LabVIEW midbrain, ROS midbrain and ROS forebrain as well as OCU code and remote emergency stop) must be running and active. If any of the code freezes or execution is suspended, LabVIEW should trigger the emergency stop. As such, as shown in Figure \ref{fig:relaycontrolportion}, the while loop  takes as input the heartbeat the represents proper running of all other layers of code from the real-time code and also a manual override that is included to allow a human operator to override the decisions of the autonomous code to control the relay. This is then fed into a subVI that determines if the heartbeat boolean is running as expected and the output of that subVI controls the state of the relay. \\ \\
%
The block diagram for that subVI is then shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.55]{Photos/relaycontrolsubvi.png}
\caption{Block diagram of the relay control subVI}
\label{fig:relaycontrolsubvi}
\end{figure}

\noindent As can be seen in Figure \ref{fig:relaycontrolsubvi}, the subVI essentially checks to see that the heartbeat is alternating between true and false each cycle through the loop. If this alternating behavior of the heartbeat is not observed, the VI will trigger the emergency stop system and shut the robot down.\\ \\
%
It must be noted at this point that although the code is designed to operate in this way, the hardware is not ready to support this. Specifically, there needs to be a hardware adapter that allows the FPGA digital I/O module (that can only source 1mA of current) to operate a relay that typically has a higher current draw than 1mA. A future team will need to adjust the relay hardware to make this relay system function in this way. 

\newpage

\section{The Real-Time Midbrain}

The LabVIEW real-time midbrain code serves the following functions:

\begin{enumerate}
\item Initialize the hardware systems on the robot
\item Transfer data between the FPGA and real-time layers
\item Transfer data between the LabVIEW real-time code and the ROS code
\item Keep track of a running mission clock (elapsed mission time)
\item Run camera data processing functions
\item Provides a state machine that serves as the real-time portion of the vehicle controller
\end{enumerate}

\noindent The block diagram of the PC-Main VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{Photos/pcmainblock_annotated.png}
\caption{Block diagram of the PC Main real-time code}
\label{fig:pcmainblock_annotated}
\end{figure}

\noindent As highlighted by the arrows and red dotted lines in Figure \ref{fig:pcmainblock_annotated}, the most important part of the PC main code is the state machine that controls the vehicle. The rest of the pieces perform the supporting roles:

\begin{enumerate}
\item Initialize communications and hardware controller settings
\item Running the process VIs that run in parallel with the PC Main VI (explained in a later section of this report)
\item Emergency stop management that passes the global emergency stop signal to the emergencys top signals in all supporting VIs
\item Shutdown robot, initialize state machine and reset estops VIs and function blocks that properly shut the state machine down and reset the state machine
\end{enumerate}

\subsection{Initialize Communications}

The block diagram for the Initialize Communications (Init Coms) VI is shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{Photos/initcommsblock.png}
\caption{Block diagram of the Initialize Communications VI}
\label{fig:initcommsblock}
\end{figure}

\noindent As can be shown in Figure \ref{fig:initcommsblock}, the Initialize Communications VI has the following parts:

\begin{enumerate}
\item Initialize Constants: This part initializes the constants that control the operation of the state machine: it sets all the estops for all parts of the code to false to ensure that all the parts of the LabVIEW code will run, sets the constants needed to display the pointcloud on the polar histrogram and initialize the logging file.
\item Create FPGA Reference: This part creates a reference to the FPGA code so that the real-time layer knows where and how to address the FPGA code.
\item Initialize Hardware Controller Settings: This series of read/write controls takes hardware settings for the steering controller, left and right LiDAR tilt unit transform settings, throttle controller settings and the left and right tilt unit controller settings. The read/write controls then sends those settings to the FPGA code using the reference specified by the FPGA reference.
\item Run FPGA VI: This invoke method node is used to run the FPGA code. It is located at this position in the initialize communications VI so that all the settings can be set before the FPGA code is run.
\item Initialize Camera VI: Initializes the camera and sets up the image spaces that are needed to store the camera parameters (see the related subsection below)
\item Initialize IMU: Sets and initializes the VISA serial port to communicate with the MicroStrain IMU
\item Initailize GPS: Sets and initializes the VISA serial port to communicate with the GPS
\item Initialize Xbox Controller: Initializes communication with an Xbox controller that could be used to control and drive the vehicle
\item Create PointCloud display: Creates the scene objet that is used to dislay the pointcloud generated from the 2 LiDARs
\item Set Initialization State: Sets boolean indicators that indicates whether the part of the initialization code excuted correctly. These are used to confirm if initialization occured fully and, if not, where in the initialization process an error occurred.
\end{enumerate}

\newpage

\subsubsection{Initialize Camera VI}

The block diagram for the Initialize Camera VI is shown below:
\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/initcamblock.png}
\caption{Block diagram of the Initialize Camera VI}
\label{fig:initcamblock}
\end{figure}

\noindent As can be seen in Figure \ref{fig:initcamblock}, the Initialize Camera VI performs the following functions in this order:

\begin{enumerate}
\item Open Camera VI: The VI opens the camera and creates a session reference that is needed by other camera function VIs
\item Configure Grab VI: Configures the grab function that can be used later to capture images using the camera
\item IMAQ Create: Creates an image space to store the image captured by the camera
\item Get Image Info: Gets the image parameters to determine the image size and type
\end{enumerate}

\newpage

\subsection{Run Parallel Processing VIs}

Referring back to Figure \ref{fig:pcmainblock_annotated}, the next step after initialization is to run the other real-time parallel processing VIs that support the operation of the vehicle. The block diagram for the Run VIs subvi is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{Photos/RunVIs.png}
\caption{Block diagram of the Run VIs VI}
\label{fig:runvis}
\end{figure}

\noindent As can be seen in Figure \ref{fig:runvis}, four VIs are run that carry out processes in parallel in the background:

\begin{enumerate}
\item Maintain FPGA Communications: Manages communication between the real-time code and FPGA code by sending commands and settings from the real-time layer to the FPGA layer and sending hardware states from the FPGA layer to the real-time layer. 
\item Maintain Mission Clock: Maintains a running mission clock
\item Run ROS Network: Runs the VI responsible for managing the transfer of data from the LabVIEW layers to the ROS layers
\item Run Camera Processes: Runs a VI responsible for assembling the pointcloud using data from the LiDARs
\end{enumerate}

\newpage

\subsubsection{Maintain FPGA Communications}

The block diagram for the Maintain FPGA communications VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.55]{Photos/MaintainFPGAComms_annotated.png}
\caption{Block diagram of the Maintain FPGA Communications VI}
\label{fig:maintainfpgacomms}
\end{figure}

\noindent As can be seen in Figure \ref{fig:maintainfpgacomms}, the VI essentially runs 4 timed while loops and 1 normal while loop in parallel to communicate with the following parts of the FPGA code:

\begin{enumerate}
\item LiDAR I/O: Communicates with the FPGA using the DMA FIFO queues that take the transformed LiDAR data as input that is then retrieved in this timed while loop. The LiDAR data is then fed to a LiDAR parser that reads the boolean array that represents the LiDAR data and determines which LiDAR (left or right) generated the data. The parser also extracts the X, Y and Z values of the LiDAR data and formats the LiDAR data into an appropriate array that is then written to either the LiDARPointsRaphael or LiDARPointsLeonardo global variables depending on which LiDAR the data originated from.
\item Vehicle Controller: Communicates with the FPGA using read/write controls to send the desired heading and velocity as well as a command to apply the brakes down to the FPGA to execute. The timed while loop also reads the state of the vehicle including, for example, the drive state, steering state and wheher the vehicle has triggered any of its steering end stops.
\item Left Tilt Unit Controller: Like the vehicle controller, this timed while loop also communicates with the FPGA using read/write controls to send the desired tilt unit command that includes, among other things, the desired position setpoint and whether the tilt unit should be in init mode or not. The commands to enable or disable the drive are also sent in this way. In addition, the timed while loop also reads the state of the tilt unit including, for example, any faults that the NI9505 module might report as well as the current position of the tilt unit.
\item Right Tilt Unit Controller: This timed while loop is exactly the same as the left tilt unit but addresses the corresponding FPGA code elements for the righ tilt unit instead of the left.
\item EStop \& State Handler: This normal while loop performs 2 functions:
\begin{enumerate}
\item Reads the error states of each while loop and ensures that all error states are false before triggering a True to indicate that the MaintainFPGACommunications VI is functioning correctly
\item Reads the global stop and passes the global stop command to the rest of the MaintainFPGACommunications VI to stop all the while loops when the global stop is triggered.
\end{enumerate}
\end{enumerate}

\subsubsection{Maintain Mission Clock}

The block diagram for the Maintain Mission Clock VI is shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.85]{Photos/maintainmissionclock.png}
\caption{Block diagram of the Maintain Mission Clock VI}
\label{fig:maintainmissionclock}
\end{figure}

\noindent The Maintain Mission Clock VI is essentially responsible for keeping a running count of the elapsed mission time in miliseconds using the tick count function. 

\newpage

\subsubsection{Run ROS Network}

The block diagram for the Run ROS Network VI is shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{Photos/rosmidbrain.png}
\caption{Block diagram of the ROS Midbrain VI}
\label{fig:rosmidbrain}
\end{figure}

\noindent As can be seen in Figure \ref{fig:rosmidbrain}, the Run Ros Network VI (also known as the ROS Midbrain network) essentially consists of 10 identical UDP transmitters that transmits the relevant data required by the ROS system by publishing the data from LabVIEW over UDP. The data being transmitted includes:

\begin{enumerate}
\item Move Base
\item Steering Angle
\item Wheel Velocity
\item EStops
\item Heartbeat
\item Left Tilt Unit Angle
\item Right Tilt Unit Angle
\item IMU
\item GPS
\item Odometer
\end{enumerate}

\noindent The VI is set up to transmit the front camera image but that has been disabled since it was not used at the time of writing of this report.\\ \\
%
Each UDP transmitter looks as shown in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/udppub.png}
\caption{Block diagram of each UDP transmitter VI}
\label{fig:udppub}
\end{figure}

\noindent Each UDP transmitter begins with the settings for the UDP transmitter: the timeout duration, port configuration and update period. This information is then passed to a UDP initialization node that creates a connection ID. The UDP connection information is then passed to a timed while loop. In that timed while loop, there are two subVIs: a VI that converts the relevant data into a string and another VI that takes that string and publishes it over UDP as specified by the UDP connection information. The timed while loop also contains a conditional that watches the global stop and shuts down the ROS network if the global estop is triggered. Finally, after the timed while loop, a function is used to shutdown the UDP connection when the estop is triggered.\\ \\
%
For brevity, this report will not discuss the various VIs that converts the relevant data into a string. However, those VIs are relatively simple and should be straightforward to read and understand.

\subsubsection{Run Camera Processes}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.45]{Photos/allimaging.png}
\caption{Block diagram for the Camera Processes VI}
\label{fig:allimaging}
\end{figure}

\noindent As can be seen in Figure \ref{fig:allimaging}, the VI starts by initializing the GlobalPCL (global pointcloud) global variable that is used to store the pointcloud that will be generated using LiDAR data from the left and right LiDARs. After initialization, the camera processes VI then performs three steps:

\begin{enumerate}
\item Capture an Image
\item Perform depth registration on the image to match X, Y and Z position data with the color of the point from the camera image
\item Populate the pointcloud array with the depth-registered data
\end{enumerate}

\noindent The block diagram for the capture image VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.85]{Photos/imagecap.png}
\caption{Block diagram for the Image Capture VI}
\label{fig:imagecap}
\end{figure}

\noindent As can be seen in Figure \ref{fig:imagecap}, the VI simply uses the grab function to grab an image using the camera and stores it in the designated name space. The VI also gets the image resolution and type and stores it along with the image.

\subsubsection{Depth Registration}
The next step is depth registration and the block diagram for that VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.75]{Photos/depthreg.png}
\caption{Block diagram for the Depth Registration VI}
\label{fig:depthreg}
\end{figure}

\noindent As can be seen in Figure \ref{fig:depthreg}, there are two steps to the depth registration process: registration to locate the LiDAR point in X-Y-Z coordinates in the image in units of pixels adn then to obtain the corresponding color for that point.

\newpage

\noindent The block diagram for the depth registration VI is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.45]{Photos/lidar2cam_annotated.png}
\caption{Block diagram for the depth registration VI}
\label{fig:lidar2cam}
\end{figure}

\noindent As can be seen in Figure \ref{fig:lidar2cam}, the process of depth registration is as follows: the VI takes the array of LiDAR points as input and iterates through each point. Each point is passed into a subVI that carries out a process known as perspective projection to locate the LiDAR point in cartesian coordinates into the location of the point in the image. As part of perspective projection, there are intrinsic parameters (parameters of the camera) as well as extrinsic parameters (parameters related to how the camera is positioned relative to the origin of the coordinate system the LiDAR points reference) that must be known to properly perform perspective projection. The output of perspective projection is the X and Y location of the point in the image in terms of pixels which is then appended to an output array.

\newpage

\subsubsection{Perspective Projection}
The perspective projection subVI is then shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.65]{Photos/perspectiveprojection.png}
\caption{Block diagram for the Perspective Projection VI}
\label{fig:perspectiveprojection}
\end{figure}

\noindent The block diagram shown in Figure \ref{fig:perspectiveprojection} is implementing the math that is involved in perspective projection. The following pages will discuss how perspective projection works.

\newpage

\includepdf[scale=0.9, pages=25-26, clip, trim=0mm 25mm 0mm 25mm, pagecommand={}]{Fall2015GatorReport.pdf}
\includepdf[scale=0.9, pages=27, clip, trim=0mm 95mm 0mm 25mm, pagecommand={}]{Fall2015GatorReport.pdf}

\subsection{The State Machine}

As shown in Figure \ref{fig:pcmainblock_annotated}, after the Run VIs VI, the next step is the state machine itself. The state machine is the key component that controls the vehicle. There are five main states to the state machine:

\begin{enumerate}
\item Initialize Robot
\item Wait for Event
\item Run Robot
\item Debug Robot
\item Shutdown
\end{enumerate}

\noindent The next few subsections will discuss each state of the state machine.

\subsubsection{Initialize Robot}

Since most of the actual initialization is done before the state machine even begins to run, the initialize robot state allows the operator to confirm that initialization was performed successfully. The front panel is shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{Photos/initrob_front.png}
\caption{Front panel of the initialize robot tab VI}
\label{fig:initrob_front}
\end{figure}

\noindent As can be seen in Figure \ref{fig:initrob_front}, the front panel of the initialize robot tab provides a panel of indicator lights that show which parts of the code have initialized properly. The front panel also provides an indicator that displays a real-time image from the front camera and an indicator for the error messages coming through the state machine to help debug any problems. Finally, the front panel provides 2 buttons:

\begin{enumerate}
\item Initialize Tilt Units: Clicking the button initiates initialization of the left and right tilt unit (discussed further below)
\item Ok button: Clicking it moves the state machine on to the wait for event state, allowing the operator to confirm that the vehicle has initialized correctly.
\end{enumerate}

\noindent The block diagram for the VI that initializes the left and right tilt unit is shown below:

 \begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{Photos/InitTiltUnits_annotated.png}
\caption{Block Diagram for the Init Tilt Units VI}
\label{fig:inittiltunits}
\end{figure}

\noindent As can be seen in Figure \ref{fig:inittiltunits}, the VI consists of a flat sequence that enforces the order of operations. That flat sequence has 5 parts:

\begin{enumerate}
\item Confirm EStops: This part confirms that the mechanical estops on the vehicle have been released before attempting to initialize the tilt units. Since power to the tilt units is controlled by the emergency stop system, the mechanical estops must be off for the tilt units to initialize properly. The dialogue box with the message to the operator will be triggered until the emergency stops are detected as released.
\item Disable Drives: This part is a safety precaution. To avoid the tilt units moving without being commanded to, both the left and right tilt unit drives are disabled to avoid the tilt units moving.
\item Wait: Creates a 10msec wait to ensure that the drives are disabled before proceeding
\item Initialize Left Tilt Unit: Initializes the left tilt unit
\item Initialize Right Tilt Unit: Initializes the right tilt unit
\end{enumerate}

\noindent The Initialize Left Tilt Unit and Initialize Right Tilt Unit VIs are essentially the same initialize tilt unit VI except that they address the appropriate variables for the left and right tilt unit. The block diagram for the initialize tilt unit VI is shown below:

 \begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{Photos/initTU.png}
\caption{Block Diagram for the VI that Initailizes the Tilt Units}
\label{fig:inittu}
\end{figure}

\noindent As can be seen in Figure \ref{fig:inittu}, the VI consists of a flat sequence that is used to ensure that a particular set of steps is used to initialize the tilt units in a strict order. There are 8 steps to initialize the tilt units corresponding to the 8 panels of the flat sequence:

\begin{enumerate}
\item Enable the drive and place the tilt unit in initialization mode to perform initialization
\item Checks the status of the NI9505 module and waits until the drive status indicates enabled before moving on in the initialization process
\item Sets the output current during initialization to 500 (which roughly corresponds to 3A), which should start moing the tilt unit. Also, records the initial milisecond count for the next step
\item In this step, the index boolean is checked within a while loop and as soon as the Index? boolean registers as true, the while loop is stopped. In this step, the loop also checks to see if 5 seconds has passed. If 5 seconds has passed, the tilt unit triggers a timeout on the initialization procedure and sets an error message as such if this happens.
\item Regardless of whether initialization times out or not, the initialization current is set to zero to stop moving the tilt unit
\item This step takes the tilt unit out of initialization mode, resets the position so that zero degrees is where the index pulse is located and sets the desired position setpoint to 35 degrees, which also corresponds to where the index pulse is located. 
\item The initialization takes a 10ms pause to allow the reset position command to reach the FPGA code
\item This last step removes the reset position command so that the tilt unit counts encoder ticks again
\end{enumerate}

\subsubsection{Wait for Event}

The wait for event state is simple: it simply provides four buttons on the front panel as shown below:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{Photos/waitforevent.png}
\caption{Front Panel for the Wait for Event State}
\label{fig:waitforevent}
\end{figure}

\noindent As can be seen in Figure \ref{fig:waitforevent}, the four button on the front panel represent these 4 options:

\begin{enumerate}
\item Run Robot: If the button is selected, the state machine will move to the Run Robot state
\item Reinitialize robot: If the button is selected, the state machine will go back to the Initialize Robot state to allow the operator to check the robot's initialization again
\item Debug Robot: If the button is selected, the state machine will go to the Debug Robot state to allow the operator to debug the functioning of the robot
\item Exit: If the button is selected, the state machine will go into Shutdown mode and shutdown the vehicle
\end{enumerate}

\noindent In the block diagram, an event handler is used to drive the Wait For Event state. When a button is clicked, the corresponding event handler is triggered and the corresponding next state is set.

\subsubsection{Run Robot}

The Run Robot state is typically used to run a mission on the vehicle. Since most of the vehicle controllers run in parallel with the state machine, the Run Robot state can be used to run particular aspects of a mission. \\ \\
%
Although the Run Robot state currently has code written in it, at the time of writing, the code was largely experimental and non-functional and therefore will not be explained. Any follow-on team should feel free to remove the code and replace it with whatever is needed. 

\subsubsection{Debug Robot}

The debug robot state is used to allow an operator to debug the functioning of the vehicle. The front panel of the debug state is shown below:

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{Photos/debugrobot.png}
\caption{Front Panel for the Debug Robot State}
\label{fig:debugrobot}
\end{figure}

\noindent As can be seen in Figure \ref{fig:debugrobot}, the front panel provides the following features:

\begin{enumerate}
\item Manual vehicle controls that allow the operator to manually command the vehicle speed and desired wheel angle
\item Current vehicle status that allows the operator to view the current vehicle speed, wheel angle, vehicle heading as well as the latitude and longitude GPS position of the vehicle
\item Graph tabs that allow the operator to view the top view and front view of the LiDAR data
\item An indicator that indicates whether the emergency stop switches have been triggered
\item Controls and indicators that allow the operator to command the position of the left and right tilt unit as well as monitor the current angle of the tillt units
\item Finally, provides 2 buttons: one to send the state machine back to the Initialize Robot state and another to send the state machine back to the Wait for Event state
\end{enumerate}

\noindent The block diagram for this state is simple. It simply takes the values read by the indicators and sends it through the global variables to the Maintain FPGA Communications VI that will send those commands down to the FPGA code. Equally, values from the FPGA code are read up through Maintain FPGA Communications VI, through the global variables and then to the indicators in this state.

\subsubsection{Shutdown}

The Shutdown state is simple: it simply triggers shutdown of the vehicle. The state has no significant front panel elements and in the block diagram, it simply sets the global estop variable to true to shutdown all levels of code.

\subsection{Shutdown Robot}

As shown in Figure \ref{fig:pcmainblock_annotated}, after the state machine triggers shutdown, the code then executes the Shutdown Robot VI. The block diagram is shown below:


\subsection{Reinitialize State Machine}
\subsection{Reset Estops}
\subsection{Emergency Stop Management}